from backtesting.lib import crossover

from strategies.base_strategy import BaseStrategy

class SimpleMACrossover(BaseStrategy):
    """
    A simple moving average (SMA) crossover strategy.

    Why this exists:
    - To provide a clear, public example of a trading strategy built upon the BaseStrategy.
    - To demonstrate how to inherit from BaseStrategy and implement a custom entry signal.
    - To serve as a baseline for benchmarking against more complex strategies.

    Signal Logic:
    - Entry: A "fast" SMA crossing over a "slow" SMA.
    - Exit: Managed by the parent BaseStrategy (trailing stop-loss and take-profit).
    """

    # --- Strategy-Specific Parameters ---
    # These can be overridden during backtest optimization.
    fast_ma_period = 10  # Lookback period for the fast moving average
    slow_ma_period = 20  # Lookback period for the slow moving average

    def init(self):
        """
        Initializes the strategy. This is where we access the pre-calculated indicators.
        """
        # Call the parent class's init to set up risk management
        super().init()

        # --- Indicator Access ---
        # The indicators were pre-calculated in the run_backtest.py script and are
        # available as columns in the data. The backtesting library makes these
        # columns available as attributes on `self.data`.
        # The column names are generated by the pandas-ta library (e.g., 'SMA_10').
        # We use getattr() to dynamically access the attribute based on the period length.
        self.fast_ma = getattr(self.data, f'SMA_{self.fast_ma_period}')
        self.slow_ma = getattr(self.data, f'SMA_{self.slow_ma_period}')

    def next(self):
        """
        The main strategy logic loop, called for each data point (bar).
        """
        # --- Entry Signal ---
        # We check if the fast MA has just crossed above the slow MA.
        # The `crossover` function returns True on the bar where the crossover occurred.
        if crossover(self.fast_ma, self.slow_ma):
            # If we don't have an open position, execute a buy.
            if not self.position:
                self.buy_instrument()
        
        # --- Exit Signal ---
        # The base strategy handles the trailing stop-loss and take-profit.
        # We can also add specific exit signals here. For example, closing
        # the position if the MAs cross back down.
        elif crossover(self.slow_ma, self.fast_ma):
            if self.position:
                self.position.close()

        # It's important to call the parent's next() method to ensure its
        # logic (like take-profit) is also executed.
        super().next()
